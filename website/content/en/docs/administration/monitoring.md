---
title: Monitoring and observing Vector
description: Use logs and metrics generated by Vector itself in your Vector topology
short: Monitoring
weight: 2
tags: ["admin", "logs", "metrics"]
---

Although Vector is primarily used to handle observability data from a wide variety of sources, we also strive to
make Vector highly observable itself. To that end, Vector provides two [sources], [`internal_logs`][internal_logs] and
[`internal_metrics`][internal_metrics], that you can use to handle logs and metrics produced by Vector just like you
would logs and metrics from any other source.

## Logs

Vector provides clear, informative, well-structured logs via the [`internal_logs`][internal_logs] source. This section
shows you how to use them in your Vector topology.

*Which* logs Vector pipes through the `internal_logs` source is determined by the [log level](#levels), which defaults
to `info`.

In addition to the `internal_logs` source, Vector also writes its logs to [`stderr`][stderr], which can be captured by
Kubernetes, SystemD, or however you are running Vector.

### Accessing logs

You can access Vector's logs by adding an [`internal_logs`][internal_logs] source to your [topology]. Here's an example
configuration that takes Vector's logs and pipes them to the console as plain text:

```yaml
sources:
  vector_logs:
    type: internal_logs

sinks:
  console:
    type: console
    inputs:
      - vector_logs
    encoding:
      codec: text
```

### Using Vector logs

Once Vector logs enter your topology through the `internal_logs` source, you can treat them like logs from any other
system, i.e. you can [transform] them and send them off to any number of [sinks]. The configuration below, for example,
transforms Vector's logs using the [`remap` transform][remap] and [Vector Remap Language][VRL] and then stores those
logs in [ClickHouse]:

```yaml
sources:
  vector_logs:
    type: internal_logs

transforms:
  modify:
    type: remap
    inputs:
      - vector_logs
    source: |
      .timestamp = to_unix_timestamp!(to_timestamp!(.timestamp))

sinks:
  database:
    type: clickhouse
    inputs:
      - modify
    host: http://localhost:8123
    table: vector-log-data
```

### Configuring logs

#### Levels

Vector logs at the `info` level by default. You can set a different level when [starting] up your instance using either
command-line flags or the `VECTOR_LOG` environment variable. The table below details these options:

Method | Description
:------|:-----------
`-v` flag | Drops the log level to `debug`
`-vv` flag | Drops the log level to `trace`
`-q` flag | Raises the log level to `warn`
`-qq` flag | Raises the log level to `error`
`-qqq` flag | Disables logging
`VECTOR_LOG=<level>` environment variable | Set the log level. Must be one of `trace`, `debug`, `info`, `warn`, `error`, `off`.

#### Stack traces

You can enable full error backtraces by setting the `RUST_BACKTRACE=full` environment variable. More on this in the
[Troubleshooting guide][troubleshooting].

## Metrics

You can monitor metrics produced by Vector using the [`internal_metrics`][internal_metrics] source. As with Vector's
[internal logs](#using-vector-logs), you can configure an `internal_metrics` source and use the piped-in metrics
however you wish. Here's an example configuration that delivers Vector's metrics to a Prometheus remote write endpoint.

```yaml
sources:
  vector_metrics:
    type: internal_metrics

sinks:
  prometheus:
    type: prometheus_remote_write
    endpoint: https://localhost:8087/
    inputs:
      - vector_metrics
```

### Metrics catalogue

The table below provides a list of internal metrics provided by Vector. See the docs for the [`internal_metrics`
source][output] for more detailed information about the available metrics and the [debugging guide][debugging_guide] on how to use them.

## Troubleshooting

More information in our troubleshooting guide:

{{< jump "/guides/level-up/troubleshooting" >}}

## How it works

### Event-driven observability

Vector employs an event-driven observability strategy that ensures consistent and correlated telemetry data. You can
read more about our approach in [RFC 2064][rfc_2064].

### Log rate limiting

Vector rate limits log events in the hot path. This enables you to get granular insight without the risk of saturating
IO and disrupting the service. The trade-off is that repetitive logs aren't logged.

[clickhouse]: /docs/reference/configuration/sinks/clickhouse
[internal_logs]: /docs/reference/configuration/sources/internal_logs
[internal_metrics]: /docs/reference/configuration/sources/internal_metrics
[journald]: https://www.freedesktop.org/software/systemd/man/systemd-journald.service.html
[journald_source]: /docs/reference/configuration/sources/journald
[output]: /docs/reference/configuration/sources/internal_metrics/#output-types
[remap]: /docs/reference/configuration/transforms/remap
[rfc_2064]: https://github.com/vectordotdev/vector/blob/master/rfcs/2020-03-17-2064-event-driven-observability.md
[sinks]: /sinks
[sources]: /sources
[starting]: /docs/administration/management
[stderr]: https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)
[topology]: /docs/introduction/concepts/#topology
[transform]: /transforms
[troubleshooting]: /guides/level-up/troubleshooting
[vrl]: /docs/reference/vrl
[debugging_guide]: /guides/developer/debugging#visualizing-and-querying-internal-metrics
