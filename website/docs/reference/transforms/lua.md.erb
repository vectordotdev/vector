<%- component = metadata.transforms.lua -%>

<%= component_header(component) %>

<%- if component.requirements.any? -%>
## Requirements

<%= component_requirements(component) %>

<%- end -%>
## Configuration

<%= component_config_example(component) %>

<%= fields(component.specific_options_list, heading_depth: 3) %>

<%- if component.env_vars_list.any? -%>
## Env Vars

<%= fields(component.env_vars_list, heading_depth: 3) %>

<%- end -%>
## Output

<Tabs
  block={true}
  defaultValue="timings"
  values={[
    { label: 'Add Fields', value: 'add_fields', },
    { label: 'Remove Fields', value: 'remove_fields', },
    { label: 'Drop Event', value: 'drop_event', },
  ]
}>

<TabItem value="add_fields">

Add a field to an event. Supply this as the `hooks.proces` value:

```lua
function (event, emit)
  # Add root level field
  event.log.new_field = "new value"
  # Add nested field
  event.log.nested.field = "nested value"

  emit(event)
end
```

</TabItem>
<TabItem value="remove_fields">

Remove a field from an event. Supply this as the `hooks.process` value:

```lua
function (event, emit)
  # Remove root level field
  event.log.field = nil
  # Remove nested field
  event.log.nested.field = nil

  emit(event)
end
```

</TabItem>
<TabItem value="drop_event">

Drop an event entirely. Supply this as the `hooks.process` value:

```lua
function (event, emit)
  # Drop event entirely by not calling the emitting function
end
```

</TabItem>
</Tabs>

## How It Works [[sort]]

<%= component_sections(component) %>

### Dropping Events

To drop events, simply not call the emitting function with it. For example:

```lua
function (event, emit)
  if not event["message"].match(str, "debug") then
    emit(event)
  end
end
```

### Types

Event fields can be set to scalar values (booleans, numbers, or strings),
and the resulting event will keep the correct types. If an event field is
set to an invalid value, a message will be logged and the field will be dropped.

### Nested Fields

As described in the [Data Model document][docs.data_model], Vector flatten
events, representing nested field with a `.` delimiter. Therefore, adding,
accessing, or removing nested fields is as simple as added a `.` in your key
name:

```lua
# Add nested field
event.log.nested.field = "nested value"

# Remove nested field
event.log.nested.field = nil
```

### Iterate over fields

To iterate over all fields of an `event` use the [`pairs`][urls.lua_pairs] method.  For example:

```lua
function (event, emit)
  # Remove all fields where the value is "-"
  for f, v in pairs(event) do
    if v == "-" then
      event[f] = nil
    end
  end

  emit(event)
end
```

### Search Directories

Vector provides a `search_dirs` option that allows you to specify absolute
paths that will searched when using the [Lua `require`
function][urls.lua_require].

### Lua Version

Vector uses the [`rlua` Rust crate][urls.rlua] which currently embeds Lua 5.3.

### Learning Lua

In order to write non-trivial transforms in Lua, one has to have basic
understanding of Lua. Because Lua is an easy to learn language, reading the
first few chapters of [the official book][urls.lua_pil] or consulting
[the manual][urls.lua_manual] would suffice.
