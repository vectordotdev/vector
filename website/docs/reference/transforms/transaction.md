---
last_modified_on: "2020-06-18"
component_title: "Transaction"
description: "The Vector `transaction` transform accepts and outputs `log` events, allowing you to reduce events of a matching transaction into a single event."
event_types: ["log"]
function_category: "aggregate"
issues_url: https://github.com/timberio/vector/issues?q=is%3Aopen+is%3Aissue+label%3A%22transform%3A+transaction%22
operating_systems: ["Linux","MacOS","Windows"]
sidebar_label: "transaction|[\"log\"]"
source_url: https://github.com/timberio/vector/tree/master/src/transforms/transaction.rs
status: "beta"
title: "Transaction Transform"
unsupported_operating_systems: []
---

import Fields from '@site/src/components/Fields';
import Field from '@site/src/components/Field';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The Vector `transaction` transform
accepts and outputs [`log`][docs.data-model.log] events, allowing you to reduce
events of a matching transaction into a single event.

<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the template located at:

     website/docs/reference/transforms/transaction.md.erb
-->

## Configuration

<Tabs
  block={true}
  defaultValue="common"
  values={[{"label":"Common","value":"common"},{"label":"Advanced","value":"advanced"}]}>
<TabItem value="common">

```toml title="vector.toml"
[transforms.my_transform_id]
  # General
  type = "transaction" # required
  inputs = ["my-source-or-transform-id"] # required
  identifier_fields = [] # optional, default

  # Ends when
  ends_when.type = "check_fields" # optional, default
  ends_when."message.eq" = "this is the content to match against" # example
  ends_when."message.eq" = ["match this", "or this"] # example
  ends_when."message.contains" = "foo" # example
  ends_when."message.contains" = ["foo", "bar"] # example
  ends_when."environment.ends_with" = "-staging" # example
  ends_when."environment.ends_with" = ["-staging", "-running"] # example
  ends_when."message.regex" = " (any|of|these|five|words) " # example
  ends_when."environment.starts_with" = "staging-" # example
  ends_when."environment.starts_with" = ["staging-", "running-"] # example
```

</TabItem>
<TabItem value="advanced">

```toml title="vector.toml"
[transforms.my_transform_id]
  # General
  type = "transaction" # required
  inputs = ["my-source-or-transform-id"] # required
  expire_after_ms = 30000 # optional, default
  flush_period_ms = 1000 # optional, default
  identifier_fields = [] # optional, default

  # Ends when
  ends_when.type = "check_fields" # optional, default
  ends_when."message.eq" = "this is the content to match against" # example
  ends_when."message.eq" = ["match this", "or this"] # example
  ends_when."host.exists" = true # example
  ends_when."method.neq" = "POST" # example
  ends_when."method.neq" = ["POST", "GET"] # example
  ends_when."message.not_contains" = "some phrase to ignore" # example
  ends_when."unit.not_starts_with" = "sys-" # example
  ends_when."unit.not_ends_with" = ".device" # example
  ends_when."message.contains" = "foo" # example
  ends_when."message.contains" = ["foo", "bar"] # example
  ends_when."environment.ends_with" = "-staging" # example
  ends_when."environment.ends_with" = ["-staging", "-running"] # example
  ends_when."message.regex" = " (any|of|these|five|words) " # example
  ends_when."environment.starts_with" = "staging-" # example
  ends_when."environment.starts_with" = ["staging-", "running-"] # example

  # Merge strategies
  merge_strategies = {message = "concat", username = "array"} # optional, no default
```

</TabItem>
</Tabs>

## Options

<Fields filters={true}>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[]}
  groups={[]}
  name={"ends_when"}
  path={null}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"table"}
  unit={null}
  warnings={[]}
  >

### ends_when

A condition used to distinguish the final event of a transaction. If this
condition resolves to true for an event the transaction it belongs to is
immediately flushed.


<Fields filters={false}>
<Field
  common={true}
  defaultValue={"check_fields"}
  enumValues={{"check_fields":"Allows you to check individual fields against a list of conditions.","is_log":"Returns true if the event is a log.","is_metric":"Returns true if the event is a metric."}}
  examples={["check_fields","is_log","is_metric"]}
  groups={[]}
  name={"type"}
  path={"ends_when"}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### type

The type of the condition to execute.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.eq":"this is the content to match against"},{"message.eq":["match this","or this"]}]}
  groups={[]}
  name={"`[field-name]`.eq"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field-name]`.eq

Check whether a fields contents exactly matches the value specified.This may be
a single string or a list of strings, in which case this evaluates to true if
any of the list matches.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"host.exists":true}]}
  groups={[]}
  name={"`[field-name]`.exists"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"bool"}
  unit={null}
  warnings={[]}
  >

#### `[field-name]`.exists

Check whether a field exists or does not exist, depending on the provided value
being `true` or `false` respectively.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"method.neq":"POST"},{"method.neq":["POST","GET"]}]}
  groups={[]}
  name={"`[field-name]`.neq"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field-name]`.neq

Check whether a fields contents does not match the value specified.This may be
a single string or a list of strings, in which case this evaluates to false if
any of the list matches.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.not_contains":"some phrase to ignore"},{"unit.not_starts_with":"sys-"},{"unit.not_ends_with":".device"}]}
  groups={[]}
  name={"`[field-name]`.not_`[condition]`"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"any"}
  unit={null}
  warnings={[]}
  >

#### `[field-name]`.not_`[condition]`

Check if the given `[condition]` does not match.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.contains":"foo"},{"message.contains":["foo","bar"]}]}
  groups={[]}
  name={"`[field_name]`.contains"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field_name]`.contains

Checks whether a string field contains a string argument.This may be a single
string or a list of strings, in which case this evaluates to true if any of the
list matches.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"environment.ends_with":"-staging"},{"environment.ends_with":["-staging","-running"]}]}
  groups={[]}
  name={"`[field_name]`.ends_with"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field_name]`.ends_with

Checks whether a string field ends with a string argument.This may be a single
string or a list of strings, in which case this evaluates to true if any of the
list matches.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.regex":" (any|of|these|five|words) "}]}
  groups={[]}
  name={"`[field_name]`.regex"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field_name]`.regex

Checks whether a string field matches a [regular expression][urls.regex].
Vector uses the [documented Rust Regex syntax][urls.rust_regex_syntax]. Note
that this condition is considerably more expensive than a regular string match
(such as `starts_with` or `contains`) so the use of those conditions are
preferred where possible.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"environment.starts_with":"staging-"},{"environment.starts_with":["staging-","running-"]}]}
  groups={[]}
  name={"`[field_name]`.starts_with"}
  path={"ends_when"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field_name]`.starts_with

Checks whether a string field starts with a string argument.This may be a
single string or a list of strings, in which case this evaluates to true if any
of the list matches.



</Field>
</Fields>

</Field>
<Field
  common={false}
  defaultValue={30000}
  enumValues={null}
  examples={[30000]}
  groups={[]}
  name={"expire_after_ms"}
  path={null}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"int"}
  unit={null}
  warnings={[]}
  >

### expire_after_ms

A maximum period of time to wait before a transaction should be considered
complete after not having received another event.



</Field>
<Field
  common={false}
  defaultValue={1000}
  enumValues={null}
  examples={[1000]}
  groups={[]}
  name={"flush_period_ms"}
  path={null}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"int"}
  unit={null}
  warnings={[]}
  >

### flush_period_ms

Controls the frequency that Vector checks for (and flushes) expired
transactions.



</Field>
<Field
  common={true}
  defaultValue={[]}
  enumValues={null}
  examples={[["request_id"],["user_id","transaction_id"]]}
  groups={[]}
  name={"identifier_fields"}
  path={null}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"[string]"}
  unit={null}
  warnings={[]}
  >

### identifier_fields

An ordered list of fields to distinguish transactions by. Each transaction has
a separate event combining state, and these fields should be used to prevent
events from unrelated transactions from combining.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"message":"concat","username":"array"}]}
  groups={[]}
  name={"merge_strategies"}
  path={null}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"table"}
  unit={null}
  warnings={[]}
  >

### merge_strategies

A map of field names to custom merge strategies. For each field specified this
strategy will be used for combining events rather than the default behavior.

The default behavior is as follows:

1. The first value of a string field is kept, subsequent values are discarded.
2. For timestamp fields the first is kept and a new field `[field_name]_end` is
   added with the last received timestamp value.
3. Numeric values are added.


<Fields filters={false}>
<Field
  common={true}
  defaultValue={null}
  enumValues={{"array":"Each value is appended to an array.","concat":"Concatenate each string value (delimited with a space).","discard":"Discard all but the first value found.","sum":"Sum all number values.","max":"The maximum of all number values.","min":"The minimum of all number values."}}
  examples={["array","concat","discard","sum","max","min"]}
  groups={[]}
  name={"`[field_name]`"}
  path={"merge_strategies"}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### `[field_name]`

The custom merge strategy to use for a field.



</Field>
</Fields>

</Field>
</Fields>

## Examples

<Tabs
  block={true}
  defaultValue="default"
  select={false}
  values={[{"label":"Default","value":"default"},{"label":"With Identifier Fields","value":"with-identifier-fields"}]}>

<TabItem value="default">

Given the following configuration:

<CodeHeader fileName="vector.toml" />

```toml
[transforms.transaction_events]
  type = "transaction"
  inputs = [...]
```

And these three [`log` events][docs.data-model.log]:

<CodeHeader fileName="first log event" />

```javascript
{
  "message": "A thing is happening",
  "custom_string_field_1": "value1",
  "this_much": 1
}
```

Followed by:

<CodeHeader fileName="second log event" />

```javascript
{
  "message": "That thing is still happening",
  "custom_string_field_2": "value2",
  "this_much": 3
}
```

And, finally:

<CodeHeader fileName="third log event" />

```javascript
{
  "message": "That thing is concluded",
  "custom_string_field_3": "value3",
  "this_much": 2
}
```

A single log event will eventually be produced:

```javascript
{
  "message": "A thing is happening",
  "custom_string_field_1": "value1",
  "custom_string_field_2": "value2",
  "custom_string_field_3": "value3",
  "this_much": 6
}
```

Notice that string values have not been overridden and integer values have been summed.

</TabItem>

<TabItem value="with-identifier-fields">

Given the following configuration:

<CodeHeader fileName="vector.toml" />

```toml
[transforms.transaction_events]
  type = "transaction"
  inputs = [...]

  identifier_fields = ["request_id"]

  [transforms.transaction_events.merge_strategies]
    request_action = "array"

  [transforms.transaction_events.ends_when]
    "request_concluded.exists" = true
```

And these three [`log` events][docs.data-model.log]:

<CodeHeader fileName="first log event" />

```javascript
{
  "message": "A thing is happening",
  "request_id": "1",
  "request_action": "start",
  "this_much": 1
}
```

Followed by:

<CodeHeader fileName="second log event" />

```javascript
{
  "message": "That thing is still happening",
  "request_id": "1",
  "request_action": "bounced",
  "this_much": 2
}
```

And:

<CodeHeader fileName="third log event" />

```javascript
{
  "message": "A different thing is happening",
  "request_id": "2",
  "request_action": "start",
  "this_much": 5
}
```

And, finally:

<CodeHeader fileName="fourth log event" />

```javascript
{
  "message": "That thing concluded",
  "request_id": "1",
  "request_action": "rebound",
  "request_concluded": true,
  "this_much": 3
}
```

A single log event will be produced and flushed immediately:

```javascript
{
  "message": "A thing is happening",
  "request_id": "1",
  "request_action": ["start","bounced","rebound"]
  "request_concluded": true,
  "this_much": 6
}
```

Notice that the fields from the third event are not present as it has been identified as a separate transaction and will be aggregated separately. Also, the values of the field `request_action` have been stored in an array instead of the default behavior.

</TabItem>
</Tabs>

## How It Works

### Complex Processing

If you encounter limitations with the `transaction`
transform then we recommend using a [runtime transform][urls.vector_programmable_transforms].
These transforms are designed for complex processing and give you the power of
full programming runtime.

### Environment Variables

Environment variables are supported through all of Vector's configuration.
Simply add `${MY_ENV_VAR}` in your Vector configuration file and the variable
will be replaced before being evaluated.

You can learn more in the
[Environment Variables][docs.configuration#environment-variables] section.

### When to use this transform

Where possible, Vector will handle event merging at the source level. For
example, the [`file`][docs.sources.file] contains a `message_start_indicator`
option and the [`docker`][docs.sources.file] contains an `auto_partial_merge`
option. Both of these options should be used instead of this transform.
Unfortunately, merging logs is not always this straight forward. It is
precisely these edge cases that this transform hopes to solve.

If you're using this transform for a common use case, please consider
[opening an issue][urls.new_feature_request] to let us know.


[docs.configuration#environment-variables]: /docs/setup/configuration/#environment-variables
[docs.data-model.log]: /docs/about/data-model/log/
[docs.sources.file]: /docs/reference/sources/file/
[urls.new_feature_request]: https://github.com/timberio/vector/issues/new?labels=type%3A+new+feature
[urls.regex]: https://en.wikipedia.org/wiki/Regular_expression
[urls.rust_regex_syntax]: https://docs.rs/regex/1.3.6/regex/#syntax
[urls.vector_programmable_transforms]: https://vector.dev/components/?functions%5B%5D=program
