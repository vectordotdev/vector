---
last_modified_on: "2020-06-24"
title: Unit Tests
description: Vector's unit test configuration options, allowing you to unit test your Vector configuration files.
status: beta
---

import Fields from '@site/src/components/Fields';
import Field from '@site/src/components/Field';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

It's possible to define unit tests within a Vector configuration file that cover
a network of transforms within the topology. The intention of these tests is to
improve the maintainability of configs containing larger and more complex
combinations of transforms.

Executing tests within a config file can be done with the `test` subcommand:

```bash
vector test /etc/vector/*.toml
```

<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the template located at:

     website/docs/reference/tests.md.erb
-->

## Configuration

<Tabs
  block={true}
  defaultValue="common"
  values={[
    { label: 'Common', value: 'common', },
    { label: 'Advanced', value: 'advanced', },
  ]
}>

<TabItem value="common">

```toml title="vector.toml"
[transforms.foo]
  type = "regex_parser"
  regex = "^(?P<timestamp>[\\w\\-:\\+]+) (?P<level>\\w+) (?P<message>.*)$"

[[tests]]
  # Inputs
  [[tests.inputs]]
    insert_at = "foo" # required
    type = "raw" # required
    value = "some message contents" # required, required when type = "raw"

  # General
  name = "foo test" # required

  # Outputs
  [[tests.outputs]]
    # Conditions
    conditions.type = "check_fields" # optional, default
    conditions."message.eq" = "this is the content to match against" # example
    conditions."message.eq" = ["match this", "or this"] # example
    conditions."message.contains" = "foo" # example
    conditions."message.contains" = ["foo", "bar"] # example
    conditions."environment.ends_with" = "-staging" # example
    conditions."environment.ends_with" = ["-staging", "-running"] # example
    conditions."message.regex" = " (any|of|these|five|words) " # example
    conditions."environment.starts_with" = "staging-" # example
    conditions."environment.starts_with" = ["staging-", "running-"] # example

    # General
    extract_from = "foo" # required
```

</TabItem>
<TabItem value="advanced">

```toml title="vector.toml"
[transforms.foo]
  type = "regex_parser"
  regex = "^(?P<timestamp>[\\w\\-:\\+]+) (?P<level>\\w+) (?P<message>.*)$"

[[tests]]
  # Inputs
  [[tests.inputs]]
    # General
    insert_at = "foo" # required
    type = "raw" # required
    value = "some message contents" # required, required when type = "raw"

    # Log fields
    log_fields.message = "some message contents" # example
    log_fields.host = "myhost" # example

    # Metric
    # General
    metric.direction = "plus" # optional, no default
    metric.name = "duration_total" # required
    metric.sample_rate = 1 # optional, no default
    metric.timestamp = "2019-11-01T21:15:47.443232Z" # required
    metric.type = "counter" # required
    metric.val = 10.2 # required

    # Tags
    metric.tags.host = "foohost" # example
    metric.tags.region = "us-east-1" # example

  # General
  name = "foo test" # required
  no_outputs_from = ["foo"] # required

  # Outputs
  [[tests.outputs]]
    # Conditions
    conditions.type = "check_fields" # optional, default
    conditions."message.eq" = "this is the content to match against" # example
    conditions."message.eq" = ["match this", "or this"] # example
    conditions."host.exists" = true # example
    conditions."method.neq" = "POST" # example
    conditions."method.neq" = ["POST", "GET"] # example
    conditions."message.not_contains" = "some phrase to ignore" # example
    conditions."unit.not_starts_with" = "sys-" # example
    conditions."unit.not_ends_with" = ".device" # example
    conditions."message.contains" = "foo" # example
    conditions."message.contains" = ["foo", "bar"] # example
    conditions."environment.ends_with" = "-staging" # example
    conditions."environment.ends_with" = ["-staging", "-running"] # example
    conditions."message.ip_cidr_contains" = "10.0.0.0/8" # example
    conditions."message.ip_cidr_contains" = ["2000::/10", "192.168.0.0/16"] # example
    conditions."message.regex" = " (any|of|these|five|words) " # example
    conditions."environment.starts_with" = "staging-" # example
    conditions."environment.starts_with" = ["staging-", "running-"] # example

    # General
    extract_from = "foo" # required
```

</TabItem>

</Tabs>

For more information about unit tests check out [this guide][guides.advanced.unit-testing].

<Fields filters={true}>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[]}
  groups={[]}
  name={"inputs"}
  path={null}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"[table]"}
  unit={null}
  warnings={[]}
  >

### inputs

A table that defines a unit test input event.


<Fields filters={false}>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={["foo"]}
  groups={[]}
  name={"insert_at"}
  path={"inputs"}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### insert_at

The name of a transform, the input event will be delivered to this transform in
order to begin the test.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[]}
  groups={[]}
  name={"log_fields"}
  path={"inputs"}
  relevantWhen={{"type":"log"}}
  required={true}
  templateable={false}
  type={"table"}
  unit={null}
  warnings={[]}
  >

#### log_fields

Specifies the log fields when the input type is 'log'.


<Fields filters={false}>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"message":"some message contents"},{"host":"myhost"}]}
  groups={[]}
  name={"`[field-name]`"}
  path={"inputs.log_fields"}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"*"}
  unit={null}
  warnings={[]}
  >

##### `[field-name]`

A key/value pair representing a field to be added to the input event.



</Field>
</Fields>

</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[]}
  groups={[]}
  name={"metric"}
  path={"inputs"}
  relevantWhen={{"type":"metric"}}
  required={true}
  templateable={false}
  type={"table"}
  unit={null}
  warnings={[]}
  >

#### metric

Specifies the metric type when the input type is 'metric'.


<Fields filters={false}>
<Field
  common={false}
  defaultValue={null}
  enumValues={{"plus":"Increase the gauge","minus":"Decrease the gauge"}}
  examples={["plus","minus"]}
  groups={[]}
  name={"direction"}
  path={"inputs.metric"}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

##### direction

The direction to increase or decrease the gauge value.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={["duration_total"]}
  groups={[]}
  name={"name"}
  path={"inputs.metric"}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

##### name

The name of the metric. Defaults to `<field>_total` for `counter` and `<field>`
for `gauge`.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[1]}
  groups={[]}
  name={"sample_rate"}
  path={"inputs.metric"}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"float"}
  unit={null}
  warnings={[]}
  >

##### sample_rate

The bucket/distribution the metric is a part of.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[]}
  groups={[]}
  name={"tags"}
  path={"inputs.metric"}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"table"}
  unit={null}
  warnings={[]}
  >

##### tags

Key/value pairs representing [metric tags][docs.data-model.metric#tags].


<Fields filters={false}>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"host":"foohost"},{"region":"us-east-1"}]}
  groups={[]}
  name={"`[tag-name]`"}
  path={"inputs.metric.tags"}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

###### `[tag-name]`

Key/value pairs representing [metric tags][docs.data-model.metric#tags].



</Field>
</Fields>

</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={["2019-11-01T21:15:47.443232Z"]}
  groups={[]}
  name={"timestamp"}
  path={"inputs.metric"}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

##### timestamp

Time metric was created/ingested.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={{"counter":"A [counter metric type][docs.data-model.metric#counter].","gauge":"A [gauge metric type][docs.data-model.metric#gauge].","histogram":"A [distribution metric type][docs.data-model.metric#distribution].","set":"A [set metric type][docs.data-model.metric#set]."}}
  examples={["counter","gauge","histogram","set"]}
  groups={[]}
  name={"type"}
  path={"inputs.metric"}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

##### type

The metric type.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[10.2]}
  groups={[]}
  name={"val"}
  path={"inputs.metric"}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"float"}
  unit={null}
  warnings={[]}
  >

##### val

Amount to increment/decrement or gauge.



</Field>
</Fields>

</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={{"raw":"Creates a log event where the message contents are specified in the field 'value'.","log":"Creates a log event where log fields are specified in the table 'log_fields'.","metric":"Creates a metric event, where its type and fields are specified in the table 'metric'."}}
  examples={["raw","log","metric"]}
  groups={[]}
  name={"type"}
  path={"inputs"}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### type

The event type.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={["some message contents"]}
  groups={[]}
  name={"value"}
  path={"inputs"}
  relevantWhen={{"type":"raw"}}
  required={true}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### value

Specifies the log message field contents when the input type is 'raw'.



</Field>
</Fields>

</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={["foo test"]}
  groups={[]}
  name={"name"}
  path={null}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

### name

A unique identifier for this test.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[["foo"]]}
  groups={[]}
  name={"no_outputs_from"}
  path={null}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"[string]"}
  unit={null}
  warnings={[]}
  >

### no_outputs_from

A list of transforms that must NOT output events in order for the test to pass.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[]}
  groups={[]}
  name={"outputs"}
  path={null}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"[table]"}
  unit={null}
  warnings={[]}
  >

### outputs

A table that defines a unit test expected output.


<Fields filters={false}>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[]}
  groups={[]}
  name={"conditions"}
  path={"outputs"}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"[table]"}
  unit={null}
  warnings={[]}
  >

#### conditions

A table that defines a collection of conditions to check against the output of
a transform. A test is considered to have passed when each condition has
resolved true for one or more events extracted from the target transform.An
expected output without conditions instead prints the input and output of a
target without checking its values.


<Fields filters={false}>
<Field
  common={true}
  defaultValue={"check_fields"}
  enumValues={{"check_fields":"Allows you to check individual fields against a list of conditions.","is_log":"Returns true if the event is a log.","is_metric":"Returns true if the event is a metric."}}
  examples={["check_fields","is_log","is_metric"]}
  groups={[]}
  name={"type"}
  path={"outputs.conditions"}
  relevantWhen={null}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

##### type

The type of the condition to execute.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.eq":"this is the content to match against"},{"message.eq":["match this","or this"]}]}
  groups={[]}
  name={"`[field-name]`.eq"}
  path={"outputs.conditions"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

##### `[field-name]`.eq

Check whether a fields contents exactly matches the value specified. This may
be a single string or a list of strings, in which case this evaluates to true
if any of the list matches.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"host.exists":true}]}
  groups={[]}
  name={"`[field-name]`.exists"}
  path={"outputs.conditions"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"bool"}
  unit={null}
  warnings={[]}
  >

##### `[field-name]`.exists

Check whether a field exists or does not exist, depending on the provided value
being `true` or `false` respectively.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"method.neq":"POST"},{"method.neq":["POST","GET"]}]}
  groups={[]}
  name={"`[field-name]`.neq"}
  path={"outputs.conditions"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

##### `[field-name]`.neq

Check whether a fields contents does not match the value specified. This may be
a single string or a list of strings, in which case this evaluates to false if
any of the list matches.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.not_contains":"some phrase to ignore"},{"unit.not_starts_with":"sys-"},{"unit.not_ends_with":".device"}]}
  groups={[]}
  name={"`[field-name]`.not_`[condition]`"}
  path={"outputs.conditions"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"any"}
  unit={null}
  warnings={[]}
  >

##### `[field-name]`.not_`[condition]`

Check if the given `[condition]` does not match.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.contains":"foo"},{"message.contains":["foo","bar"]}]}
  groups={[]}
  name={"`[field_name]`.contains"}
  path={"outputs.conditions"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

##### `[field_name]`.contains

Checks whether a string field contains a string argument. This may be a single
string or a list of strings, in which case this evaluates to true if any of the
list matches.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"environment.ends_with":"-staging"},{"environment.ends_with":["-staging","-running"]}]}
  groups={[]}
  name={"`[field_name]`.ends_with"}
  path={"outputs.conditions"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

##### `[field_name]`.ends_with

Checks whether a string field ends with a string argument. This may be a single
string or a list of strings, in which case this evaluates to true if any of the
list matches.



</Field>
<Field
  common={false}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.ip_cidr_contains":"10.0.0.0/8"},{"message.ip_cidr_contains":["2000::/10","192.168.0.0/16"]}]}
  groups={[]}
  name={"`[field_name]`.ip_cidr_contains"}
  path={"outputs.conditions"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

##### `[field_name]`.ip_cidr_contains

Checks whether an IP field is contained within a given [IP CIDR][urls.cidr]
(works with IPv4 and IPv6). This may be a single string or a list of strings,
in which case this evaluates to true if the IP field is contained within any of
the CIDRs in the list.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"message.regex":" (any|of|these|five|words) "}]}
  groups={[]}
  name={"`[field_name]`.regex"}
  path={"outputs.conditions"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

##### `[field_name]`.regex

Checks whether a string field matches a [regular expression][urls.regex].
Vector uses the [documented Rust Regex syntax][urls.rust_regex_syntax]. Note
that this condition is considerably more expensive than a regular string match
(such as `starts_with` or `contains`) so the use of those conditions are
preferred where possible.



</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={[{"environment.starts_with":"staging-"},{"environment.starts_with":["staging-","running-"]}]}
  groups={[]}
  name={"`[field_name]`.starts_with"}
  path={"outputs.conditions"}
  relevantWhen={{"type":"check_fields"}}
  required={false}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

##### `[field_name]`.starts_with

Checks whether a string field starts with a string argument. This may be a
single string or a list of strings, in which case this evaluates to true if any
of the list matches.



</Field>
</Fields>

</Field>
<Field
  common={true}
  defaultValue={null}
  enumValues={null}
  examples={["foo"]}
  groups={[]}
  name={"extract_from"}
  path={"outputs"}
  relevantWhen={null}
  required={true}
  templateable={false}
  type={"string"}
  unit={null}
  warnings={[]}
  >

#### extract_from

The name of a transform, at the end of the test events extracted from this
transform will be checked against a table of conditions.



</Field>
</Fields>

</Field>
</Fields>


[docs.data-model.metric#counter]: /docs/about/data-model/metric/#counter
[docs.data-model.metric#distribution]: /docs/about/data-model/metric/#distribution
[docs.data-model.metric#gauge]: /docs/about/data-model/metric/#gauge
[docs.data-model.metric#set]: /docs/about/data-model/metric/#set
[docs.data-model.metric#tags]: /docs/about/data-model/metric/#tags
[guides.advanced.unit-testing]: /guides/advanced/unit-testing/
[urls.cidr]: https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing
[urls.regex]: https://en.wikipedia.org/wiki/Regular_expression
[urls.rust_regex_syntax]: https://docs.rs/regex/1.3.6/regex/#syntax
