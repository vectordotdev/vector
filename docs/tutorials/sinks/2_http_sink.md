Most Vector sinks involve some form of network connectivity. Connecting to a network
requires more involved functionality that we have covered so far in our basic sink.
This tutorial will modify our sink to send the events to an HTTP endpoint. We will 
cover a number of Vector components that make adding this functionality easy.

# imports

To start, update our imports to the following:

```rust
use std::task::Poll;

use crate::{
    config::{GenerateConfig, SinkConfig, SinkContext},
    http::HttpClient,
    internal_events::SinkRequestBuildError,
    sinks::util::{
        encoding::{write_all, Encoder},
        metadata::RequestMetadataBuilder,
        request_builder::EncodeResult,
        Compression, RequestBuilder, SinkBuilderExt,
    },
    sinks::Healthcheck,
};
use bytes::Bytes;
use futures::{future::BoxFuture, stream::BoxStream, StreamExt};
use vector_common::{
    finalization::{EventFinalizers, EventStatus, Finalizable},
    internal_event::CountByteSize,
    request_metadata::{MetaDescriptive, RequestMetadata},
};
use vector_config::configurable_component;
use vector_core::{
    config::{AcknowledgementsConfig, Input},
    event::Event,
    sink::{StreamSink, VectorSink},
    stream::DriverResponse,
    tls::TlsSettings,
};
```

# Configuration

First we want to update our config to allow an endpoint to be specified. Add this
field to the `BasicConfig` struct:

```rust
    /// The endpoint to send HTTP traffic to.
    #[configurable(metadata(
        docs::examples = "http://localhost:3000/",
        docs::examples = "http://example.com/endpoint/",
    ))]
    pub endpoint: String,
```

Every field in the configuration struct must have a comment. This is used to 
generate documentation for the Sink. The metadata attribute added here is used
to generate examples for the documentation. (This is possible because the config
struct is annotated with `#[configurable_component(sink("basic"))]`).

We then want to update our sink to take the endpoint from the config. At the same 
time let's create an `HttpClient` that will handle sending the data. `HttpClient` 
is our wrapper over [`hyper`][hyper_docs] used to send data over http.

Update the `BasicSink` struct to look like: 

```rust
#[derive(Debug, Clone)]
struct BasicSink {
    endpoint: String,
    client: HttpClient,
}

impl BasicSink {
    pub fn new(config: &BasicConfig) -> Self {
        let tls = TlsSettings::from_options(&None).unwrap();
        let client = HttpClient::new(tls, &Default::default()).unwrap();
        let endpoint = config.endpoint.clone();

        Self { client, endpoint }
    }
}
```

# Encoder

Now we want to create an Encoder that will take our event and convert it 
to raw bytes.

```rust
#[derive(Clone)]
struct BasicEncoder;
```

The Encoder must implement the `Encoder` trait:

```rust
impl Encoder<Event> for BasicEncoder {
    fn encode_input(
        &self,
        input: Event,
        writer: &mut dyn std::io::Write,
    ) -> std::io::Result<usize> {
    }
}
```

The `Encoder` trait is generic over the type of input that we are 
expecting. In our case it is `Event` since we will be encoding a single
event at a time. Other Sinks may encode a `Vec<Event>`  if they are 
sending batches of events, or they may send a completely different type
if each event is processed in someway prior to encoding.


The `encode_input` serializes the event to a String and writes these
bytes:
 
```rust
    fn encode_input(
        &self,
        input: Event,
        writer: &mut dyn std::io::Write,
    ) -> std::io::Result<usize> {
        let event = serde_json::to_string(&input).unwrap();
        write_all(writer, 1, event.as_bytes()).map(|()| event.len())
    }
```

# Request Builder

Next we creata request builder that turns the event into a request. The 
request is used by a Tower service that is responsible for actually sending
the data.

The request looks like:

```rust
#[derive(Clone)]
struct BasicRequest {
    payload: Bytes,
    finalizers: EventFinalizers,
    metadata: RequestMetadata,
}
```

The fields in the request are:

## payload

The payload is the actual bytes that we will be sending out. These are the bytes
generated by our `BasicEncoder`.

## finalizers

`EventFinalizers` is a collection of `Finalizers`. A `Finalizer` is used to track 
the status of a given event and is used to support 
[end to end acknowledgements](https://vector.dev/docs/about/under-the-hood/guarantees/#acknowledgement-guarantees).

## metadata

The metadata contains additional data that is used to emit various metrics when 
a request is successfully sent.


We need to implement a number of traits for the request to access these fields:

```rust
impl MetaDescriptive for BasicRequest {
    fn get_metadata(&self) -> RequestMetadata {
        self.metadata
    }
}

impl Finalizable for BasicRequest {
    fn take_finalizers(&mut self) -> EventFinalizers {
        self.finalizers.take_finalizers()
    }
}
```

The request builder must implement the `RequestBuilder<>` trait: 

```rust
impl RequestBuilder<Event> for BasicRequestBuilder {
```

There are a number of stages in the request builder process -  first the input 
is split out into metadata and actual event data. The event data is encoded. 
The results from the encoding are are passed with the metadata to create the 
final request that is passed to the `Tower` sink.

Here, the trait is generic over `Event` which is the input type that is 
passed in to start the request building process.

There are a number of associated types:

```rust
    type Metadata = EventFinalizers;
    type Events = Event;
    type Encoder = BasicEncoder;
    type Payload = Bytes;
    type Request = BasicRequest;
    type Error = std::io::Error;
```

## Metadata

`Metadata` is the type for any information to be passed while building the request
that is additional to the actual event being used. In this case we just need the
`EventFinalizers`.

## Events

Events contains the type that is the event type passed to the `Encoder`.

## Encoder

The `Encoder` is the type that is used to encode the event to create the final
payload. We are using the `BasicEncoder` described earlier.

## Payload

The `Payload` is the type of the final data that is encoded.

## Request

`Request` is the type that is sent to the final service. This is the `BasicRequest`
we described earlier.

## Error

`Error` is the type of any errors that are creating while encoding the event.


The following functions for the `RequestBuilder` trait need implementing:

## compression

```rust
    fn compression(&self) -> Compression {
        Compression::None
    }
```

The payload for the built request can be compressed. Here we return `Compression::None`
to indicate that we will not be compressing. `Compression::Gzip` and `Compression::Zlib`
are available choices.


## encoder

```rust
    fn encoder(&self) -> &Self::Encoder {
        &self.encoder
    }
```

We return the encoder to use. This is the `BasicEncoder` defined earlier.


## split_input

```rust
    fn split_input(
        &self,
        mut input: Event,
    ) -> (Self::Metadata, RequestMetadataBuilder, Self::Events) {
        let finalizers = input.take_finalizers();
        let metadata_builder = RequestMetadataBuilder::from_events(&input);
        (finalizers, metadata_builder, input)
    }
```

`split_input` takes the input and extracts the metadata from the events. In this
case we are returning the `input` parameter unprocessed. 

This may not always be the case. For example, the `amqp` sink will initially
process  the event to extract fields to be used to calculate the exchange
to send the message  to. This is sent  with the event to `split_input`.
`split_input` splits that out into the event for  encoding and the metadata
containing the exchange which will be used when sending  the event to `amqp`.


## build_request

```rust
    fn build_request(
        &self,
        metadata: Self::Metadata,
        request_metadata: RequestMetadata,
        payload: EncodeResult<Self::Payload>,
    ) -> Self::Request {
        BasicRequest {
            finalizers: metadata,
            payload: payload.into_payload(),
            metadata: request_metadata,
        }
    }
```

`build_request` is used to build the final request that will contain the encoded
payload and the metadata. The `BasicRequest` object we return here is passed to 
our `Tower` service where the data is actually sent.

# Service

We need to create a service that is responsible for actually sending our final
encoded data.

```rust
struct BasicService {
    endpoint: String,
    client: HttpClient,
}
```

The two fields the service contains, `endpoint` and `client` are the `endpoint`
and `client` passed in from the `BasicSink` described earlier.

`BasicService` implements the `tower::Service` trait:

```rust
impl tower::Service<BasicRequest> for BasicService {
}
```
    
A number of associated types need defining:

```rust        
    type Response = BasicResponse;
    type Error = &'static str;
    type Future = BoxFuture<'static, Result<Self::Response, Self::Error>>;
```
    
## poll_ready

`poll_ready` is used to indicate when the service is ready to send data. This service
has no reason to block, so we always return `Poll::Ready`.

```rust
    fn poll_ready(
        &mut self,
        _cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Result<(), Self::Error>> {
        Poll::Ready(Ok(()))
    }
```

## call

`call` is where the data is actually sent over http. It returns a future that will
be invoked to send the actual data.

```rust
    fn call(&mut self, request: BasicRequest) -> Self::Future {
        let byte_size = request.payload.len();
        let body = hyper::Body::from(request.payload);
        let req = http::Request::post(&self.endpoint)
            .header("Content-Type", "application/json")
            .body(body)
            .unwrap();

        let mut client = self.client.clone();

        Box::pin(async move {
            match client.call(req).await {
                Ok(response) => {
                    if response.status().is_success() {
                        Ok(BasicResponse { byte_size })
                    } else {
                        Err("received error response")
                    }
                }
                Err(_error) => Err("oops"),
            }
        })
    }
```

That future returns `BasicResponse`.

# BasicResponse

The return from our service must be an object that implements the `DriverResponse` trait.

```rust
struct BasicResponse {
    byte_size: usize,
}

impl DriverResponse for BasicResponse {
    fn event_status(&self) -> EventStatus {
        EventStatus::Delivered
    }

    fn events_sent(&self) -> CountByteSize {
        // (events count, byte size)
        CountByteSize(1, self.byte_size)
    }
}
```

Vector calls the methods in this trait to determine if the event was delivered successfully.
This is used for metrics and the end to end acknowledgements.

# Sink

Finally, we need to update the `run_inner` method of our `BasicSink` trait.

```rust
    async fn run_inner(self: Box<Self>, input: BoxStream<'_, Event>) -> Result<(), ()> {
        let service = tower::ServiceBuilder::new().service(BasicService {
            client: self.client.clone(),
            endpoint: self.endpoint.clone(),
        });

        let sink = input
            .request_builder(
                None,
                BasicRequestBuilder {
                    encoder: BasicEncoder,
                },
            )
            .filter_map(|request| async move {
                match request {
                    Err(error) => {
                        emit!(SinkRequestBuildError { error });
                        None
                    }
                    Ok(req) => Some(req),
                }
            })
            .into_driver(service);

        sink.run().await
    }
```

After creating our service, we run a number of custom extension methods on `BoxStream` that 
process the stream of events.

## request_builder

`request_builder` indicates which request builder to use to build our request. We pass in 
the `BasicRequestBuilder` described earlier. The first parameter is the limit to the number
of concurrent request builders that should be in operation at any time. We pass `None` which
means no limit is applied.

## filter_map

If building the request errors, we want to emit an error and then filter the event from being 
processed further. 

## into_driver

The Driver is the final stage of the process that drives the interaction between the stream
of incoming events and the `BasicService` we created above.


# Running our sink

We can now run our new sink.

Let's run a test Http server to accept the responses our sink sends:

```sh
docker run -p 3000:3000 plork/httpdump
```

Our sink has a new configuration field for the endpoint. Update it to look like:

```yaml
sinks:
  basic:
    type: basic
    endpoint: http://localhost:3000
    inputs:
      - stdin
```

Then run Vector:

```sh
cargo run -- -c ./basic.yml
```

If we type something into the console, this should now be sent to our Http server:

```sh
METHOD:  POST
URI:     /

HEADERS:
content-type      application/json
user-agent        Vector/0.26.0 (x86_64-unknown-linux-gnu debug=full)
accept-encoding   identity
host              localhost:3000
content-length    131

BODY:
{"log":{"host":"computer","message":"zork","source_type":"stdin","timestamp":"2023-01-23T10:21:57.215019942Z"}}
```

[hyper_docs]: https://docs.rs/hyper/latest/hyper/