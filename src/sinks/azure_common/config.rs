use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use tokio::{
    task,
    time::{Duration, sleep},
};

use base64::Engine;
use openssl::{hash, pkey, sign};
use percent_encoding::{NON_ALPHANUMERIC, utf8_percent_encode};

use crate::sinks::azure_common::http::build_reqwest_with_proxy;
use azure_core::http::{ClientOptions, Transport};
use azure_core::{Error, error::ErrorKind};
use bytes::Bytes;
use futures::FutureExt;
use http::StatusCode;
use snafu::Snafu;
use vector_lib::config::proxy::ProxyConfig;
use vector_lib::{
    json_size::JsonSize,
    request_metadata::{GroupedCountByteSize, MetaDescriptive, RequestMetadata},
    stream::DriverResponse,
};

use crate::{
    event::{EventFinalizers, EventStatus, Finalizable},
    sinks::{Healthcheck, util::retries::RetryLogic},
};

/// Request generated by the Azure Blob sink for a single upload attempt.
#[derive(Debug, Clone)]
pub struct AzureBlobRequest {
    pub blob_data: Bytes,
    pub content_encoding: Option<&'static str>,
    pub content_type: &'static str,
    pub metadata: AzureBlobMetadata,
    pub request_metadata: RequestMetadata,
}

impl Finalizable for AzureBlobRequest {
    fn take_finalizers(&mut self) -> EventFinalizers {
        std::mem::take(&mut self.metadata.finalizers)
    }
}

impl MetaDescriptive for AzureBlobRequest {
    fn get_metadata(&self) -> &RequestMetadata {
        &self.request_metadata
    }

    fn metadata_mut(&mut self) -> &mut RequestMetadata {
        &mut self.request_metadata
    }
}

/// Per-request metadata captured for accounting and observability.
#[derive(Clone, Debug)]
pub struct AzureBlobMetadata {
    pub partition_key: String,
    pub count: usize,
    pub byte_size: JsonSize,
    pub finalizers: EventFinalizers,
}

/// Retry logic for Azure Blob sink requests using azure_core::Error.
#[derive(Debug, Clone)]
pub struct AzureBlobRetryLogic;

impl RetryLogic for AzureBlobRetryLogic {
    type Error = Error;
    type Request = AzureBlobRequest;
    type Response = AzureBlobResponse;

    fn is_retriable_error(&self, error: &Self::Error) -> bool {
        match error.kind() {
            ErrorKind::HttpResponse { status, .. } => {
                // Retry on 5xx and 429
                status.is_server_error() || *status == azure_core::http::StatusCode::TooManyRequests
            }
            _ => false,
        }
    }
}

/// Upload response wrapper for the sink driver.
#[derive(Debug)]
pub struct AzureBlobResponse {
    pub inner: (),
    pub events_byte_size: GroupedCountByteSize,
    pub byte_size: usize,
}

impl DriverResponse for AzureBlobResponse {
    fn event_status(&self) -> EventStatus {
        EventStatus::Delivered
    }

    fn events_sent(&self) -> &GroupedCountByteSize {
        &self.events_byte_size
    }

    fn bytes_sent(&self) -> Option<usize> {
        Some(self.byte_size)
    }
}

/// Healthcheck error variants specific to Azure Blob.
#[derive(Debug, Snafu)]
pub enum HealthcheckError {
    #[snafu(display("Invalid connection string specified"))]
    InvalidCredentials,
    #[snafu(display("Container: {:?} not found", container))]
    UnknownContainer { container: String },
    #[snafu(display("Unknown status code: {}", status))]
    Unknown { status: StatusCode },
}

/// Execute a healthcheck by requesting container properties.
///
/// Maps common HTTP errors (403/404) to typed healthcheck errors.
pub fn build_healthcheck(
    container_name: String,
    client: Arc<RwLock<Arc<azure_storage_blob::BlobContainerClient>>>,
) -> crate::Result<Healthcheck> {
    let healthcheck = async move {
        // Official SDK: get container properties (no options required for a basic check).
        let client = client.read().expect("lock poisoned").clone();
        let response = client.get_properties(None).await;

        let resp: crate::Result<()> = match response {
            Ok(_) => Ok(()),
            Err(error) => {
                match error.kind() {
                    ErrorKind::HttpResponse { status, .. } => {
                        // Convert azure_core status -> http::StatusCode for existing error type.
                        let parsed = status
                            .to_string()
                            .parse::<u16>()
                            .ok()
                            .and_then(|code| StatusCode::from_u16(code).ok());
                        match parsed {
                            Some(StatusCode::FORBIDDEN) => {
                                Err(Box::new(HealthcheckError::InvalidCredentials))
                            }
                            Some(StatusCode::NOT_FOUND) => {
                                Err(Box::new(HealthcheckError::UnknownContainer {
                                    container: container_name,
                                }))
                            }
                            Some(status) => Err(Box::new(HealthcheckError::Unknown { status })),
                            None => Err("unknown status code".into()),
                        }
                    }
                    _ => Err(error.into()),
                }
            }
        };
        resp
    };

    Ok(healthcheck.boxed())
}

/// Build a BlobContainerClient using SAS from a connection string.
///
/// This builder supports only SAS-based authentication. The connection string is expected to
/// include at least:
/// - `BlobEndpoint=https://<account>.blob.core.windows.net/`
/// - `SharedAccessSignature=sv=...&ss=b&srt=...&...`
///
/// The SAS token is appended to the Blob endpoint URL. Authentication is handled by SAS on the URL,
/// so an anonymous credential is used.
pub fn build_client(
    connection_string: String,
    container_name: String,
    proxy: &ProxyConfig,
) -> crate::Result<Arc<RwLock<Arc<azure_storage_blob::BlobContainerClient>>>> {
    // Attempt SAS path first
    let parsed_sas = parse_sas_connection_string(&connection_string);
    // Fallback to AccountName/AccountKey path (we'll generate and rotate SAS)
    let parsed_shared_key = parsed_sas
        .as_ref()
        .err()
        .and_then(|_| parse_account_key_connection_string(&connection_string).ok());

    // Build per-sink reqwest client and inject as transport into ClientOptions
    let http: std::sync::Arc<reqwest_0_12::Client> =
        std::sync::Arc::new(build_reqwest_with_proxy(proxy)?);
    let client_options = ClientOptions {
        transport: Some(Transport::new(http.clone())),
        ..Default::default()
    };
    let options = azure_storage_blob::BlobContainerClientOptions {
        client_options,
        ..Default::default()
    };

    // If we have SAS in the connection string, build once and return a static client.
    if let Ok((blob_endpoint, sas)) = parsed_sas {
        let endpoint = if blob_endpoint.contains('?') {
            blob_endpoint
        } else {
            format!("{}?{}", blob_endpoint.trim_end_matches('/'), sas)
        };

        #[allow(deprecated)]
        let credential = azure_identity::DeveloperToolsCredential::new(None)
            .map_err(|e| format!("Failed to construct credential for SAS auth: {e}"))?;
        let client = azure_storage_blob::BlobContainerClient::new(
            &endpoint,
            container_name,
            credential,
            Some(options),
        )
        .map_err(|e| format!("Failed to create Azure Blob container client: {e}"))?;

        return Ok(Arc::new(RwLock::new(Arc::new(client))));
    }

    // Otherwise, we have AccountName/AccountKey and will generate an account-signed SAS and rotate it.
    let (account_name, account_key, base_endpoint) = parsed_shared_key
        .ok_or_else(|| "Connection string must include either SAS (BlobEndpoint+SharedAccessSignature) or AccountName+AccountKey".to_string())?;

    // Initial SAS + client
    let (initial_sas, ttl) = generate_account_sas(&account_name, &account_key)?;
    let current_endpoint = format!("{}?{}", base_endpoint.trim_end_matches('/'), initial_sas);
    #[allow(deprecated)]
    let credential = azure_identity::DeveloperToolsCredential::new(None)
        .map_err(|e| format!("Failed to construct credential for SAS auth: {e}"))?;
    let initial = azure_storage_blob::BlobContainerClient::new(
        &current_endpoint,
        container_name.clone(),
        credential.clone(),
        Some(options.clone()),
    )
    .map_err(|e| format!("Failed to create Azure Blob container client: {e}"))?;
    let handle = Arc::new(RwLock::new(Arc::new(initial)));

    // Spawn background SAS rotation task
    {
        let handle_clone = Arc::clone(&handle);
        let account_name = account_name.clone();
        let account_key = account_key.clone();
        let container_name = container_name.clone();
        let options = options.clone();
        let _http = http.clone();

        // Refresh at ~80% of TTL, with a minimum cadence and a small guard band
        let refresh_after =
            Duration::from_secs((ttl.as_secs().saturating_mul(80)).saturating_div(100))
                .max(Duration::from_secs(300));
        task::spawn(async move {
            loop {
                sleep(refresh_after).await;

                match generate_account_sas(&account_name, &account_key) {
                    Ok((sas, _new_ttl)) => {
                        let new_endpoint =
                            format!("{}?{}", base_endpoint.trim_end_matches('/'), sas);
                        // Rebuild client with the rotated SAS
                        // Note: we reuse the same credential placeholder and options (transport includes proxy)
                        let rotated = azure_storage_blob::BlobContainerClient::new(
                            &new_endpoint,
                            container_name.clone(),
                            credential.clone(),
                            Some(options.clone()),
                        );
                        if let Ok(rotated_client) = rotated {
                            _ = new_endpoint;
                            if let Ok(mut guard) = handle_clone.write() {
                                *guard = Arc::new(rotated_client);
                            }
                        }
                    }
                    Err(_e) => {
                        // Best-effort: keep using the current SAS; we'll retry on next tick
                        // Consider adding metrics/logging here.
                    }
                }
            }
        });
    }

    return Ok(handle);
}

/// Parse a minimal SAS connection string to extract `BlobEndpoint` and `SharedAccessSignature`.
fn parse_sas_connection_string(s: &str) -> Result<(String, String), String> {
    let mut map: HashMap<&str, &str> = HashMap::new();
    for part in s.split(';').filter(|p| !p.is_empty()) {
        if let Some((k, v)) = part.split_once('=') {
            map.insert(k.trim(), v.trim());
        }
    }

    let endpoint = map
        .get("BlobEndpoint")
        .ok_or_else(|| "missing `BlobEndpoint`".to_string())?
        .to_string();
    let sas = map
        .get("SharedAccessSignature")
        .ok_or_else(|| "missing `SharedAccessSignature`".to_string())?
        .to_string();

    Ok((endpoint, sas))
}

/// Parse AccountName/AccountKey and derive a base Blob endpoint.
///
/// Supports either:
/// - explicit BlobEndpoint
/// - or DefaultEndpointsProtocol + EndpointSuffix to build https://{account}.blob.{suffix}/
fn parse_account_key_connection_string(s: &str) -> Result<(String, String, String), String> {
    let mut map: HashMap<&str, &str> = HashMap::new();
    for part in s.split(';').filter(|p| !p.is_empty()) {
        if let Some((k, v)) = part.split_once('=') {
            map.insert(k.trim(), v.trim());
        }
    }

    let account = map
        .get("AccountName")
        .ok_or_else(|| "missing `AccountName`".to_string())?
        .to_string();
    let key = map
        .get("AccountKey")
        .ok_or_else(|| "missing `AccountKey`".to_string())?
        .to_string();

    let endpoint = if let Some(be) = map.get("BlobEndpoint") {
        be.to_string()
    } else {
        let proto = map
            .get("DefaultEndpointsProtocol")
            .cloned()
            .unwrap_or("https");
        let suffix = map
            .get("EndpointSuffix")
            .cloned()
            .unwrap_or("core.windows.net");
        format!("{proto}://{account}.blob.{suffix}/")
    };

    Ok((account, key, endpoint))
}

/// Generate an account-signed SAS for the Blob service with minimal permissions needed by the sink.
/// Returns the SAS query string (without leading '?') and the TTL used.
fn generate_account_sas(
    _account_name: &str,
    account_key_b64: &str,
) -> Result<(String, Duration), String> {
    // TTL configuration: 7 days default, renew at ~80%
    let ttl = Duration::from_secs(7 * 24 * 60 * 60);

    // Times (with small skew)
    let now = chrono::Utc::now() - chrono::Duration::minutes(5);
    let expiry = now + chrono::Duration::from_std(ttl).map_err(|_| "invalid TTL")?;

    // Minimal, conservative permissions:
    // - Container: read/list properties (rl)
    // - Object: create/write (cw)
    // Resource types: container+object (srt=co), service: blob (ss=b)
    // Scope SAS for HTTPS only (spr=https)
    let sv = "2024-11-04"; // match a recent service version understood by the account
    let ss = "b";
    let srt = "co";
    let sp = "rlcw";
    let se = expiry.to_rfc3339_opts(chrono::SecondsFormat::Secs, true);
    let st = now.to_rfc3339_opts(chrono::SecondsFormat::Secs, true);
    let spr = "https";

    // Canonical string-to-sign for an account SAS (subset sufficient for our needs):
    // Format (reference Azure docs for account SAS string-to-sign):
    // sp\nst\nse\nss\nsrt\nsv\nspr\n\n
    let string_to_sign = format!("{sp}\n{st}\n{se}\n{ss}\n{srt}\n{sv}\n{spr}\n");

    // Sign with HMAC-SHA256(key=AccountKey)
    let key_bytes = base64::engine::general_purpose::STANDARD
        .decode(account_key_b64)
        .map_err(|e| format!("invalid AccountKey base64: {e}"))?;
    let key = pkey::PKey::hmac(&key_bytes).map_err(|e| format!("invalid HMAC key: {e}"))?;
    let mut signer = sign::Signer::new(hash::MessageDigest::sha256(), &key)
        .map_err(|e| format!("failed to create HMAC signer: {e}"))?;
    signer
        .update(string_to_sign.as_bytes())
        .map_err(|e| format!("failed to sign SAS string: {e}"))?;
    let sig = signer
        .sign_to_vec()
        .map_err(|e| format!("failed to finalize HMAC: {e}"))?;
    let sig_b64 = base64::engine::general_purpose::STANDARD.encode(sig);

    // Assemble SAS (URL-encode parameters)
    let se_enc = utf8_percent_encode(&se, NON_ALPHANUMERIC).to_string();
    let st_enc = utf8_percent_encode(&st, NON_ALPHANUMERIC).to_string();
    let sig_enc = utf8_percent_encode(&sig_b64, NON_ALPHANUMERIC).to_string();

    let sas = format!(
        "sv={sv}&ss={ss}&srt={srt}&sp={sp}&se={se}&st={st}&spr={spr}&sig={sig}",
        se = se_enc,
        st = st_enc,
        sig = sig_enc
    );

    Ok((sas, ttl))
}
